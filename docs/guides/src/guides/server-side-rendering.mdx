import { CodeBlock } from '../components/CodeBlock';

# Server-side Rendering: The Best of Both Worlds

Welcome back, wise architect! You've learned how to build applications that are fast, scalable, real-time, and that allow users to upload their own files. But what if you want to take your applications to the next level? What if you want to build applications that are not only powerful and feature-rich, but also blazingly fast and SEO-friendly? Well, my friend, you've come to the right place. In this section, we're going to learn how to do server-side rendering (SSR) with Effect RPC.

## What is Server-side Rendering?

Server-side rendering is the process of rendering your application on the server, and then sending the fully rendered HTML to the client. This is in contrast to client-side rendering (CSR), where the client is responsible for rendering the application.

### Why is it so important?

Server-side rendering is important for two main reasons:

*   **Performance:** With SSR, the user sees the fully rendered page almost instantly. This is because the server sends the fully rendered HTML to the client, so the client doesn't have to wait for the JavaScript to download and execute before it can see the content.
*   **SEO:** With SSR, search engines can easily crawl and index your site. This is because the server sends the fully rendered HTML to the client, so the search engine doesn't have to execute any JavaScript to see the content.

## Server-side Rendering with Effect RPC

With Effect RPC, you can do server-side rendering with any framework you want. However, our favorite framework for SSR is [Next.js](https://nextjs.org/). Next.js is a popular React framework that makes it easy to do server-side rendering.

### Using Next.js

Here's an example of how to do server-side rendering with Effect RPC and Next.js:

<CodeBlock language="typescript">{`// pages/index.tsx
import { GetServerSideProps } from 'next'
import { client } from '../client'
import { api } from '../api'

type Props = {
  todo: api['getTodo']['output']
}

export default function IndexPage({ todo }: Props) {
  return (
    <div>
      <h1>{todo.title}</h1>
      <p>{todo.completed ? 'Completed' : 'Pending'}</p>
    </div>
  )
}

export const getServerSideProps: GetServerSideProps<Props> = async () => {
  const todo = await client.getTodo({ id: 1 })
  return {
    props: {
      todo,
    },
  }
}
`}</CodeBlock>

In this example, we're using the `getServerSideProps` function from Next.js to fetch the data on the server. We're then passing the data to our component as props. The component is then rendered on the server, and the fully rendered HTML is sent to the client.

## The Best of Both Worlds

And that's it! You've learned how to do server-side rendering with Effect RPC. You've learned about the benefits of SSR, and you've learned how to use Next.js to do SSR with Effect RPC. You're now ready to build applications that are not only powerful and feature-rich, but also blazingly fast and SEO-friendly.

You now have the best of both worlds. You have the power and flexibility of Effect RPC, and you have the performance and SEO benefits of SSR. So, go out there, build amazing things, and never stop learning. The world is waiting for your next masterpiece.
